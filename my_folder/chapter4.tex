%! suppress = Unicode
\chapter{ТЕСТИРОВАНИЕ РЕАЛИЗАЦИИ} \label{ch:ch4}

В этой главе мы проверим работоспособность разработанного адаптера, а также оценим его влияние на производительность системы, в которой он может быть внедрён.

\section{Данные для тестирования реализации}\label{sec:ch4-testing-data}

Для тестирования сервиса R2G планируется использовать публичные GraphQL-сервисы.
В частности, сервис FakeQL позволяет создать GraphQL-сервис на основании данных в виде JSON. Для этого используем JSON, представленный в приложении 5.
Данный JSON загружается на сайт FakeQL, после чего мы получаем URL эндпоинта, к которому можно отправлять GraphQL-запросы.
Схема получившегося сервиса была продемонстрирована ранее (см. приложение 1).

В приложении 6 продемонстрирован пример маппинга. % TODO номер приложения
для получения списка счетов в валюте из query parameter, для пользователя с идентификатором, переданным в URI. В приложении 7 представлен пример запроса, который соответствует указанному маппингу, а также GraphQL-запрос, который должен быть отправлен в GraphQL-сервер при получении такого запроса.

\section{Функциональное тестирование} \label{sec:ch4-functional}

	Для проверки работоспособности были использованы тестовые данные, подготовленные в главе 2.
	Проверяются следующие сценарии:

\begin{itemize}
	\item Для запроса существует маппинг, не содержащий переменных.
	Система отправляет GraphQL-сервису шаблон из маппинга в неизменном виде и возвращает пользователю ответ.

	\item Для запроса существует маппинг, содержащий несколько переменных.
	Система заполняет шаблон этими переменными и отправляет результат GraphQL-сервису, возвращает пользователю ответ.

    \item Для запроса не существует маппинг.
	Запрос в неизменном виде перенаправляется по адресу Gateway API, указанному в настройках.
	В данном случае использовался сервис Postman Echo, возвращающий body и headers запроса в качестве ответа.
	Ответ этого сервиса возвращается пользователю.
\end{itemize}

Все сценарии были успешно проверены.

\section{Тестирование производительности} \label{sec:ch4-performance}

Так как данный адаптер будет обрабатывать каждый запрос в системе, то среднее время отклика (latency) системы увеличится на величину, равную среднему времени на получение, обработку и отправку запроса разрабатываемой системой (overhead).
Измерим это время для разных сценариев.
Так как время ответа сервера FakeQL непостоянно, то замер общего времени выполнения запроса не будет показательным.
Чтобы определить overhead разработанного адаптера, необходимо замерить время выполнения в нескольких срезах.
% TODO воспользоваться wiremock и запилить нагрузочное тестирование гатлингом

Для каждого тестового запроса будем производить замеры в 8 моментах времени:
\begin{enumerate}
	\item при отправке запроса из клиента, в качестве которого будем использовать Postman;
	\item при получении запроса Spring Framework;
	\item при передаче управления в компонент RequestProcessService;
	\item при отправке запроса из GraphService
	\item при получении ответа в GraphService
	\item при возврате обработанного ответа из RequestProcessService;
	\item при отправке результата клиенту;
	\item при получении результата клиентом Postman.
\end{enumerate}
Соответственно, мы получаем четыре среза, на основании которых сможем сделать выводы о производительности приложения, а также рассмотреть возможные пути повышения его скорости.

Таким образом, мы сможем высчитать overhead при предобработке запроса Spring Framework, так также время логики нашего адаптера.
Все отправляемые в данном случае запросы абсолютно идентичны, что позволит оценить влияние каких-либо случайных факторов на время выполнения каждого этапа работы адаптера.
Результаты замеров изображены в \taref{tab:performance-slices}, значения представлены в миллисекундах.

\noindent
\begingroup
\centering
\small %выставляем шрифт в 12bp
\begin{table} [htbp]
	\centering\small
	\caption{Результаты замеров}%
	\label{tab:performance-slices}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		№ запроса & 1-8 & 2-7 & 3-6 & 4-5 \\ \hline
		\hline
		1 & 734 & 685 & 673 & 669 \\ \hline
		2 & 162 & 154 & 148 & 147 \\ \hline
		3 & 184 & 182 & 179 & 178 \\ \hline
		4 & 415 & 396 & 387 & 385 \\ \hline
		5 & 648 & 644 & 638 & 638 \\ \hline
	\end{tabular}
\end{table}
\normalsize
\endgroup

Соответственно, в столбце \textbf{1-8} время с момента отправки запроса из Postman до момента получения ответа.
В столбце \textbf{2-7} время с момента получения запроса фреймворком до момента отправки им ответа.
В столбце \textbf{3-6} время с момента начала обработки запроса нашим кодом до момента возвращения результата фреймворку для отправки клиенту.
В столбце \textbf{4-5} время с момента отправки запроса в GraphQL-сервис до момента получения ответа от него.

На \taref{tab:performance-slices-diff} посчитана разницу между каждой парой соседних столбцов, в миллисекундах.

\noindent
\begingroup
\centering
\small %выставляем шрифт в 12bp
\begin{table} [htbp]
	\centering\small
	\caption{Результаты замеров}%
	\label{tab:performance-slices-diff}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		\textbf{№ запроса} & \textbf{сеть} & \textbf{фреймворк} & \textbf{наша логика} \\ \hline
		\hline
		\textbf{1} & 35 & 12 &  4 \\ \hline
		\textbf{2} &  8 &  6 &  1 \\ \hline
		\textbf{3} &  2 &  3 &  1 \\ \hline
		\textbf{4} & 19 &  9 &  2 \\ \hline
		\textbf{5} &  4 &  6 &  0 \\ \hline
	\end{tabular}
\end{table}
\normalsize
\endgroup

В столбце \textbf{сеть} посчитано общее время на передачу запроса от клиента к адаптеру.
Среднее значение составило $13.6$ мс.

В столбце \textbf{фреймворк} указано время, потраченное Spring Framework на преобразование HTTP-запроса и его предобработки для передачи нашему коду.
Среднее значение составляет $7.2$ мс.

В столбце \textbf{наша логика} указано время, потраченное на поиск маппинга, подготовку запроса из шаблона, а также на обработку ответа от GraphQL-сервера.
Среднее значение составляет $1.6$ мс.

Как видно, время работы бизнес-логики при обработке запроса ($1.6$ мс) -- поиска маппинга, заполнения запроса, отправки его в GraphQL-сервер и постобработки результата запроса -- является относително незначительным по сравнению с другими.
Данные в этом столбце на самом деле не являются показательными -- время передачи данных между клиентом и адаптером зависит от скорости интернет-соединения.

% TODO протестировать для ForwarderService
% TODO оценить время разных этапов (поиска маппинга, создания шаблона, преобразования и т.п.)

\section{Возможности улучшения производительности} \label{sec:ch4-performance-improve}

Рассмотрим способы улучшения показателей скорости работы адаптера:

\begin{itemize}
	\item \textbf{Время обработки зарпоса фреймворком}.
		Данный показатель можно улучшить, используя вместо Spring Framework более легковесные фреймворки, например KTor или Netty, и неблокирующий ввод/вывод.
		Также, в качестве веб-сервера вместо Tomcat может использоваться более оптимальный Jetty.

	\item \textbf{Время обработки запроса нашим кодом}.
		Это время может значительно возрасти при увеличении количества маппингов, так как для каждого запроса осуществляется поочерёдное сравнение пути запроса с путём в маппинге с помощью регулярных выражений.
То есть с ростом количества маппингов будет линейно расти количество необходимых сравнений для нахождения нужного.
Таким образом, поиск маппингов можно считать "узким горлышком" нашей логики.
Улучшить это время можно за счёт использования иных структур данных и логики поиска для хранения маппингов.
Например, маппинги можно разделить на группы по HTTP-методу, сузив область для поиска до нескольких раз.
А с помощью префиксного дерева можно находить среди них маппинги по пути (\texttt{path}) с логарифмической сложностью.

	Также достаточно затратным по времени и памяти процессом может являться заполнение шаблона.
	Ускорить этот процесс можно, предобработав шаблон заранее -- на этапе запуска сервиса можно предобработать все шаблоны для использования \texttt{String.format} или другого, более эффективного способа заполнения шаблонов.
\end{itemize}

\section{Выводы} \label{ch4:conclusion}

Таким образом, мы доказали работоспособность предлагаемой технологии, а также оценили влияние использования разработанного адаптера на производительность системы, в которой он будет внедрён.
Помимо этого, предложены варианты улучшения разработанной системы с целью уменьшения этого влияния.


% TODO chapter5 -- перспективы развития и возможности внедрения