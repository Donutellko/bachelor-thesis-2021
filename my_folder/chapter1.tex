%! suppress = Unicode
\chapter{ВВЕДЕНИЕ В ПРЕДМЕТНУЮ ОБЛАСТЬ} \label{ch:ch1}

В данной главе мы рассмотрим технологии, широко использующиеся в разработке программного обеспечения для организации взаимодействия между различными системами, в частности для обмена данными между клиентом и сервером.
Рассмотрим их принципы, достоинства и недостатки,

\section{Технология REST}\label{sec:rest}

REST (Representational state transfer) это архитектурный стиль взаимодействия.
REST не является протоколом или стандартом, в отличие от SOAP, так как не даёт строгих правил взаимодействия, например позволяя передавать в запрос и ответ как JSON, так и XML или бинарные файлы.
Однако он накладывает ряд ограничений\cite{fielding-dissertation}, при соблюдении которых сервис считается RESTful:

\textbf{Разделение сервера и клиента}

Логика и визуальный интерфейс клиента, за которые отвечает клиентское приложение, не затрагивают то, каким образом данные хранятся и обрабатываются на сервере.
Благодаря этому облегчается создание других клиентских приложений и улучшается масштабируемость за счёт упрощения компонентов сервера.

\textbf{Отсутствие состояния}

Каждый запрос рассматривается отдельно, сервер не хранит контекст для клиента, что улучшает масштабируемость, использование ресурсов и отказоустойчивость, однако может увеличить нагрузку на сеть за счёт того, что часть данных будет передаваться с каждым запросом.

\textbf{Кэширование}

Клиенты и промежуточные узлы должны иметь возможность кешировать ответы сервера, а ответы сервера должны явно или неявно указывать на возможность кеширования.
Очевидным образом это улучшает производительность и отказоустойчивость системы.

\textbf{Единообразие интерфейса}

Этот принцип позволяет каждому сервису развиваться независимо.

Вот ряд признаков такого интерфейса:
\begin{itemize}
	\item Идентификация ресурса – каждый ресурс и каждый управляемый им объект имеет уникальный идентификатор – URI и ID, соответственно.
	Например, для получения списка выставленных счетов мы можем обратиться с запросом \texttt{GET /api/invoices}, и в ответе получить информацию о счетах с идентификаторами \texttt{123} и \texttt{567}.
	\item Манипуляция ресурсами через представление – клиент имеет возможность модифицировать информацию на основании метаданных, получаемых в других запросах.
	Например, получив ID объекта в одном запросе, он может удалить этот объект по ID в другом.
	В предыдущем пункте мы получили счёт с идентификатором \texttt{123}, и мы можем удалить этот счёт с помощью запроса \texttt{DELETE /api/invoices/123}.
	\item Самоописываемые сообщения – запрос и ответ содержит достаточно информации, чтобы понять, как его обрабатывать.
	Например, сообщение может иметь заголовок с MIME-типом: \texttt{Content-Type: application/json}.
	\item Гипермедиа как способ управление состоянием – клиенту не требуется заранее знать, как взаимодействовать с системой за пределами гипермедиа.
	Например, получая информацию о балансе, клиент получает список возможных с ним действий.
	В частности, при отрицательном балансе в списке действий не будет вывода денег, а лишь опция пополнить счёт, и данная логика не должна быть заложена приложении-клиенте.
\end{itemize}

\textbf{Слои}

Структура системы является иерархической, клиент может взаимодействовать с ресурсом не напрямую, что позволяет повысить масштабируемость за счёт кеширования и балансировки нагрузки на промежуточных узлах.
А также наличие слоёв позволяет добавить абстракцию от устаревших (legacy) компонентов системы и устаревших клиентов, добавив перед ними сервисы-адаптеры.
Например, при переходе на API версии 2, можно создать сервис, предоставляющий API версии 1, который сам будет обращаться к API версии 2.

\textbf{Код по требованию}

Это ограничение указано как «необязательное» ограничение, допускающее в архитектуре системы использование загружаемого кода в виде апплетов.


\section{Технология GraphQL}\label{sec:graphql}

GraphQL это открытый язык запросов для получения и манипуляции данными.
В отличие от REST, он имеет достаточно строгую спецификацию\cite{graphql-introduction}.
Система, работающая с GraphQL, имеет так называемую schema, которая описывает API. Схема состоит из сущностей нескольких типов: object, query и mutation.
Object является самой простой из них и представляет собой набор полей, являющихся другими объектами, коллекциями объектов или скалярами – строками, целыми числами, числами с плавающей запятой, булевыми значениями или ID. Поля также могут принимать аргументы: например, при получении информации о сумме денег на счету пользователя, мы можем передать валюту, в которой хотим получить ответ.
Query и mutation являются особыми типами объектов, использующимися для получения и изменения данных соответственно.

Приведём пример запросов и ответов на GraphQL. Примеры будут выполняться на схеме, продемонстрированной в приложении 1.
Данная схема имеет сущности User, Account и Card, а также ряд query и mutations, некоторые из которых сейчас будут рассмотрены.

\textbf{Пример выполнения query}

Создадим запрос для получения списка валютных счетов и привязанных к этим счетам карт пользователей, отсортированных по имени в алфавитном порядке.

В приложении 2 представлены выполняемый запрос слева и полученный ответ справа.
Разберём его более детально.
В строке 2 указываем, что хотим получить список users, отсортированный по полю имя (name).
Для каждого пользователя получаем его id, имя (name), а также список счетов (account).
Среди счетов нас интересуют те, значения валюты (currency) которых не равно RUR, это условие учтено в строке 5.
И для каждого счёта получаем id, остаток (amount), валюту (currency) и список карт (cards).
Для каждой карты получаем её маскированный номер (number\_masked) и платёжную систему (system).

Как видно из результата выполнения, в ответ были получили только поля, указанные в запросе.

\textbf{Пример выполнения mutation}

Изменим сумму на счету у одного из пользователей, полученных в прошлом запросе.

Для этого воспользуемся mutation под названием updateAccount, установив новое значение amount для счёта с идентификатором 4.
В этом же запросе получим в ответ обновлённое состояние счёта, а также имя пользователя, которому этот счёт принадлежит.
Запрос и ответ продемонстрированы в приложении 3.


\section{Сравнение технологий REST и GraphQL}\label{sec:rest-vs-graphql}

\subsection{Преимущества GraphQL}\label{subsec:graphql-advantages}

Некоторые преимуществ, получаемые при использовании GraphQL и соответствующего ему подхода, уже были перечислены во введении, однако рассмотрим их детальнее\cite{graphql-why-use} \cite{rest-soap-graphql-guide}:

\textbf{Клиент может конкретно указать, какие данные ему требуются и в каком виде.}

Это позволяет сэкономить количество сетевых вызовов, обращений к базе данных, памяти и файловой системе, сэкономить трафик и избавиться от лишних преобразований, конвертаций и сортировок.
Предположим, есть сервис, который выводит топ-25 фотографий пользователя в высоком качестве, отсортированными по количеству лайков и с несколькими лучшими комментариями.
Затем на странице профиля потребовалось выводить превью пяти последних фотографий, с сортировкой по дате, для чего был добавлен новый эндпоинт.
Затем потребовалось создать мобильные версии для обоих экранов, в которых количество фотографий меньше, не отображаются комментарии, а вместо полноразмерных изображений используются миниатюры.
Это потребует двух доработок на стороне сервера, что было посчитано нецелесообразным ввиду недостатка времени у разработчиков.
В итоге на стороне сервера осуществляется лишний запрос для получения комментариев к изображению, а пользователь тратит время и трафик на загрузку изображений в большом качестве.
В случае с GraphQL разработчику клиента в обоих случаях достаточно будет лишь изменить в запросе способ сортировки и количество запрашиваемых элементов, а в списке получаемых полей поменять ссылку на изображение на ссылку на превью.

\textbf{Упрощается агрегация данных из нескольких источников в одном запросе.}

Допустим, у нас есть сервис, предоставляющий информацию о счетах, и сервис, предоставляющий информацию о картах.
Чтобы получить информацию о счетах и привязанных к ним картам, придётся либо сделать два запроса и сопоставить их результаты на стороне клиента, либо создать ещё один сервис, агрегирующий информацию и предоставляющий её в требуемом нам виде.
При использовании GraphQL один сервис, называемый BFF (Backend For Frontend), является универсальным агрегатором.

\textbf{Используется система типов для описания данных.}

Схема является контрактом между клиентом и сервером, позволяет задать для запросов и ответов типы полей, списки возможных значений (enum), обязательность их наличия (nullability).

\subsection{Недостатки GraphQL}\label{subsec:graphql-disadvantages}

Однако GraphQL имеет и недостатки в сравнении с REST\cite{rest-soap-graphql-guide}\cite{graphql-whats-wrong}:

\textbf{Необходимость в управлении дополнительными ограничениями.}\label{graphql-disadvantage-constraints}

Так как потребитель GraphQL API имеет возможность самостоятельно выбирать те данные, которые он хочет получить, встаёт вопрос безопасности.
Например, недобросовестный пользователь может отправить на сервер запрос для получения полной информации обо всех пользователях, чтобы использовать их в целях, идущих вразрез с интересами компании.
Либо отправить множество ресурсоёмких запросов с целью вызвать отказ в обслуживании этого сервиса.
Для предотвращения обоих атак разработчику необходимо задавать дополнительные ограничения, предугадывая возможные способы злоупотребления.
В качестве решения данной проблемы некоторые реализации GraphQL-серверов имеют механизм Persistent Queries\cite{graphql-persistent-queries}, позволяющих задавать все возможные запросы, и затем обращаться к ним по уникальному идентификатору.
Хотя такой подход позволяет решить вопрос безопасности, но лишают гибкости.

\textbf{Отсутствующее поле и null неотличимы.}\label{graphql-disadvantage-missing-or-null}

Например, существует запрос mutation для обновления информации о пользователе, позволяющий изменять его имя, адрес и номер телефона.
Эти поля могут присутствовать или отсутствовать в запросе, чтобы клиенту не приходилось отправлять адрес и номер телефона, если он хочет изменить имя.
Однако если пользователь захочет полностью удалить значение адреса, передав null, то сервер решит, что поле адреса не должно быть изменено.

\textbf{Отличие формата ввода и вывода.}\label{graphql-disadvantage-input-output-differ}

Для иллюстрации воспользуемся одним из принципов REST – отсутствием состояния.
Допустим, в одном запросе клиент получил некий контекст, который он должен передать в следующем запросе.
В случае REST сервер и клиент обмениваются идентичным объектом.
А в случае с GraphQL для этой цели в схеме должны быть определены отдельные типы для ввода и вывода, а на клиенте осуществляться составление запроса с использованием полей из ответа.

\textbf{Отсутствие поддержки полиморфизма для mutation.}\label{graphql-disadvantage-polymorphism}

В то время как для object можно задать другой object в качестве интерфейса (либо использовать union), для полей в mutation наследование не предусмотрено.
Например, нужно передать информацию о владельце счёта.
Если владельцем является физическое лицо, то нужны его фамилия, имя и отчество, а для юридического лица – наименование предприятия.
В случае с REST клиент может передать дополнительное поле, содержащее тип владельца счёта, и сервер сможет осуществить десериализацию в нужный тип.
А при использовании GraphQL придётся создать отдельный запрос для каждого типа.

\textbf{Отсутствие namespaces.}\label{graphql-disadvantage-namespaces}

Один GraphQL сервис имеет единственную схему.
В случае большого проекта схема может достигать значительных объёмов, и ориентирование в ней потребует наличие дополнительной документации, а также увеличивается вероятность коллизии имён.
REST в свою очередь не использует такое понятие как тип передаваемого объекта, и управление ими осуществляется средствами клиента и сервера в отдельности.

\textbf{Недостатки механизмов кеширования.}\label{graphql-disadvantage-caching}

На уровне HTTP технология GraphQL по умолчанию использует метод POST для осуществления запросов.
Но механизмы кеширования HTTP не предназначены для кеширования POST-запросов\cite{graphqlcaching}.
Предполагается, что кеширование может быть реализовано на стороне клиента или в рамках самого GraphQL-сервера\cite{graphql-apollo-server-caching}, но не на промежуточных узлах.
Также предлагается использовать GET-запрос, содержащий query в качестве параметра, однако это предполагает наличие контроля над клиентами.


Как видно, обе технологии имеют свои преимущества и недостатки, но решение об использовании того или иного подхода должно приниматься с учётом специфики конкретного проекта.


\section{Проблемы миграции на GraphQL}\label{sec:migration-to-graphql}\label{graphql-disadvantage-migration}

В случае, если разработчики решат начать использовать GraphQL в уже существующем продукте, они могут столкнуться с рядом проблем.
Чтобы наглядно продемонстрировать возможные проблемы, рассмотрим пример.

Допустим, что некая компания имеет мобильное приложение для платформ Android и iOS, а также веб-версии приложений для компьютеров и мобильных устройств.
Часть пользователей не имеет возможности обновлять приложение из-за того, что их версия операционной системы больше не поддерживается приложением, однако компания не желает терять прибыль от этих пользователей.

В компании периодически производится редизайн приложения, в связи с чем на большом количестве экранов меняется формат представления данных, в связи с чем должны быть изменены и форматы запросов к серверу и ответов от него.
Из-за большого количества имеющихся платформ сильно возрастает нагрузка на разработчиков серверной части, так как необходимо разрабатывать сервисы с учётом различий в представлении результата на каждой платформе.

Использование GraphQL позволило бы снизить нагрузку на разработчиков серверной части, так как в этом случае им достаточно создать ряд универсальных источников и предоставить схему, для которой разработчики клиентских приложений будут писать запросы.

Однако внедрение новой технологии означает, что её использованию необходимо обучить каждого разработчика каждой из платформ, а затем в течение длительного времени поддерживать одновременно две версии API – GraphQL для новых версий приложения, и REST для старых.


\section{Выводы} \label{sec:conclusion}

Таким образом, мы рассмотрели некоторые из современных технологий, используемые для организации клиент-серверного взаимодействия.
Были рассмотрены их основные принципы, а также преимущества и недостатки технологий в сравнении друг с другом.
В результате было получено понимание проблем, с которыми сталкиваются разработчики, реализующие системы с их использованием, или осуществляющие миграцию между ними.
Соответственно, это понимание позволит заняться поиском решения для перечисленных проблем.