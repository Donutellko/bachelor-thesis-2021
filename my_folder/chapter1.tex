%! suppress = Unicode


\chapter{ТЕОРЕТИЧЕСКАЯ ЧАСТЬ} \label{ch:ch1}

% не рекомендуется использовать отдельную section <<введение>> после лета 2020 года
%\section{Введение. Сложносоставное название первого параграфа первой главы для~демонстрации переноса слов в содержании} \label{ch1:intro}

Хорошим стилем является наличие введения к главе, которое \textit{начинается непосредственно после названия главы, без оформления в виде отдельного параграфа}.
Во введении может быть описана цель написания главы, а также приведена краткая структура главы.
Например, в параграфе \ref{ch1:sec1} приведены примеры оформления одиночных формул, рисунков и таблицы.
Параграф \ref{ch1:sec2} посвящён многострочным формулам и сложносоставным рисункам.

Текст данной главы призван привести \textit{краткие} примеры оформления текстово-графических объектов.
Более подробные примеры можно посмотреть в следующей главе, а также в рекомендациях студентам \cite{spbpu-student-thesis-template-author-guide}.


\section{Технология REST}\label{sec:rest}

REST (Representational state transfer) это архитектурный стиль взаимодействия.
REST не является протоколом или стандартом, в отличие от SOAP, так как не даёт строгих правил взаимодействия, например позволяя передавать в запрос и ответ как JSON, так и XML или бинарные файлы.
Однако он накладывает ряд ограничений [1], при соблюдении которых сервис считается RESTful:

\textbf{Разделение сервера и клиента}

Логика и визуальный интерфейс клиента, за которые отвечает клиентское приложение, не затрагивают то, каким образом данные хранятся и обрабатываются на сервере.
Благодаря этому облегчается создание других клиентских приложений и улучшается масштабируемость за счёт упрощения компонентов сервера.

\textbf{Отсутствие состояния}

Каждый запрос рассматривается отдельно, сервер не хранит контекст для клиента, что улучшает масштабируемость, использование ресурсов и отказоустойчивость, однако может увеличить нагрузку на сеть за счёт того, что часть данных будет передаваться с каждым запросом.

\textbf{Кэширование}

Клиенты и промежуточные узлы должны иметь возможность кешировать ответы сервера, а ответы сервера должны явно или неявно указывать на возможность кеширования.
Очевидным образом это улучшает производительность и отказоустойчивость системы.

\textbf{Единообразие интерфейса}

Этот принцип позволяет каждому сервису развиваться независимо.

Вот ряд признаков такого интерфейса:
\begin{itemize}
	\item Идентификация ресурса – каждый ресурс и каждый управляемый им объект имеет уникальный идентификатор – URI и ID, соответственно.
	Например, для получения списка выставленных счетов мы можем обратиться с запросом GET /api/invoices, и в ответе получить информацию о счетах с идентификаторами 123 и 567.
	\item Манипуляция ресурсами через представление – клиент имеет возможность модифицировать информацию на основании метаданных, получаемых в других запросах.
	Например, получив ID объекта в одном запросе, он может удалить этот объект по ID в другом.
	В предыдущем пункте мы получили счёт с идентификатором 123, и мы можем удалить этот счёт с помощью запроса DELETE /api/invoices/123.
	\item Самоописываемые сообщения – запрос и ответ содержит достаточно информации, чтобы понять, как его обрабатывать.
	Например, сообщение может иметь заголовок с MIME-типом: Content-Type: application/json.
	\item Гипермедиа как способ управление состоянием – клиенту не требуется заранее знать, как взаимодействовать с системой за пределами гипермедиа.
	Например, получая информацию о балансе, клиент получает список возможных с ним действий.
	В частности, при отрицательном балансе в списке действий не будет вывода денег, а лишь опция пополнить счёт, и данная логика не должна быть заложена приложении-клиенте.
\end{itemize}

\textbf{Слои}

Структура системы является иерархической, клиент может взаимодействовать с ресурсом не напрямую, что позволяет повысить масштабируемость за счёт кеширования и балансировки нагрузки на промежуточных узлах.
А также наличие слоёв позволяет добавить абстракцию от устаревших (legacy) компонентов системы и устаревших клиентов, добавив перед ними сервисы-адаптеры.
Например, при переходе на API версии 2, можно создать сервис, предоставляющий API версии 1, который сам будет обращаться к API версии 2.

\textbf{Код по требованию}

Это ограничение указано как «необязательное» ограничение, допускающее в архитектуре системы использование загружаемого кода в виде апплетов.


\section{Технология GraphQL}\label{sec:graphql}

GraphQL это открытый язык запросов для получения и манипуляции данными.
В отличие от REST, он имеет достаточно строгую спецификацию [2].
Система, работающая с GraphQL, имеет так называемую schema, которая описывает API. Схема состоит из сущностей нескольких типов: object, query и mutation.
Object является самой простой из них и представляет собой набор полей, являющихся другими объектами, коллекциями объектов или скалярами – строками, целыми числами, числами с плавающей запятой, булевыми значениями или ID. Поля также могут принимать аргументы: например, при получении информации о сумме денег на счету пользователя, мы можем передать валюту, в которой хотим получить ответ.
Query и mutation являются особыми типами объектов, использующимися для получения и изменения данных соответственно.

Приведём пример запросов и ответов на GraphQL. Примеры будут выполняться на схеме, продемонстрированной в приложении 1.
Данная схема имеет сущности User, Account и Card, а также ряд query и mutations, некоторые из которых сейчас будут рассмотрены.

\textbf{Пример выполнения query}

Создадим запрос для получения списка валютных счетов и привязанных к этим счетам карт пользователей, отсортированных по имени в алфавитном порядке.

В приложении 2 представлены выполняемый запрос слева и полученный ответ справа.
Разберём его более детально.
В строке 2 указываем, что хотим получить список users, отсортированный по полю имя (name).
Для каждого пользователя получаем его id, имя (name), а также список счетов (account).
Среди счетов нас интересуют те, значения валюты (currency) которых не равно RUR, это условие учтено в строке 5.
И для каждого счёта получаем id, остаток (amount), валюту (currency) и список карт (cards).
Для каждой карты получаем её маскированный номер (number\_masked) и платёжную систему (system).

Как видно из результата выполнения, в ответ были получили только поля, указанные в запросе.

\textbf{Пример выполнения mutation}

Изменим сумму на счету у одного из пользователей, полученных в прошлом запросе.

Для этого воспользуемся mutation под названием updateAccount, установив новое значение amount для счёта с идентификатором 4.
В этом же запросе получим в ответ обновлённое состояние счёта, а также имя пользователя, которому этот счёт принадлежит.
Запрос и ответ продемонстрированы в приложении 3.


\section{Сравнение технологий REST и GraphQL}\label{sec:rest-vs-graphql}

\subsection{Преимущества GraphQL}\label{subsec:graphql-advantages}

Некоторые преимуществ, получаемые при использовании GraphQL и соответствующего ему подхода, уже были перечислены во введении, однако рассмотрим их детальнее [3, 4]:

\textbf{Клиент может конкретно указать, какие данные ему требуются и в каком виде.}

Это позволяет сэкономить количество сетевых вызовов, обращений к базе данных, памяти и файловой системе, сэкономить трафик и избавиться от лишних преобразований, конвертаций и сортировок.
Предположим, есть сервис, который выводит топ-25 фотографий пользователя в высоком качестве, отсортированными по количеству лайков и с несколькими лучшими комментариями.
Затем на странице профиля потребовалось выводить превью пяти последних фотографий, с сортировкой по дате, для чего был добавлен новый эндпоинт.
Затем потребовалось создать мобильные версии для обоих экранов, в которых количество фотографий меньше, не отображаются комментарии, а вместо полноразмерных изображений используются миниатюры.
Это потребует двух доработок на стороне сервера, что было посчитано нецелесообразным ввиду недостатка времени у разработчиков.
В итоге на стороне сервера осуществляется лишний запрос для получения комментариев к изображению, а пользователь тратит время и трафик на загрузку изображений в большом качестве.
В случае с GraphQL разработчику клиента в обоих случаях достаточно будет лишь изменить в запросе способ сортировки и количество запрашиваемых элементов, а в списке получаемых полей поменять ссылку на изображение на ссылку на превью.

\textbf{Упрощается агрегация данных из нескольких источников в одном запросе.}

Допустим, у нас есть сервис, предоставляющий информацию о счетах, и сервис, предоставляющий информацию о картах.
Чтобы получить информацию о счетах и привязанных к ним картам, придётся либо сделать два запроса и сопоставить их результаты на стороне клиента, либо создать ещё один сервис, агрегирующий информацию и предоставляющий её в требуемом нам виде.
При использовании GraphQL один сервис, называемый BFF (Backend For Frontend), является универсальным агрегатором.

\textbf{Используется система типов для описания данных.}

Схема является контрактом между клиентом и сервером, позволяет задать для запросов и ответов типы полей, списки возможных значений (enum), обязательность их наличия (nullability).

\subsection{Недостатки GraphQL}\label{subsec:graphql-disadvantages}

Однако GraphQL имеет и недостатки в сравнении с REST [4, 5]:

\textbf{Необходимость в управлении дополнительными ограничениями.}

Так как потребитель GraphQL API имеет возможность самостоятельно выбирать те данные, которые он хочет получить, встаёт вопрос безопасности.
Например, недобросовестный пользователь может отправить на сервер запрос для получения полной информации обо всех пользователях, чтобы использовать их в целях, идущих вразрез с интересами компании.
Либо отправить множество ресурсоёмких запросов с целью вызвать отказ в обслуживании этого сервиса.
Для предотвращения обоих атак разработчику необходимо задавать дополнительные ограничения, предугадывая возможные способы злоупотребления.
Также у некоторых реализаций есть механизм Persistent Queries, позволяющих задавать все возможные запросы, и обращаться к ним по уникальному идентификатору.

\textbf{Отсутствующее поле и null неотличимы.}

Например, существует запрос mutation для обновления информации о пользователе, позволяющий изменять его имя, адрес и номер телефона.
Эти поля могут присутствовать или отсутствовать в запросе, чтобы клиенту не приходилось отправлять адрес и номер телефона, если он хочет изменить имя.
Однако если пользователь захочет полностью удалить значение адреса, передав null, то сервер решит, что поле адреса не должно быть изменено.

\textbf{Отличие формата ввода и вывода.}

Для иллюстрации воспользуемся одним из принципов REST – отсутствием состояния.
Допустим, в одном запросе клиент получил некий контекст, который он должен передать в следующем запросе.
В случае REST сервер и клиент обмениваются идентичным объектом.
А в случае с GraphQL для этой цели в схеме должны быть определены отдельные типы для ввода и вывода, а на клиенте осуществляться составление запроса с использованием полей из ответа.

\textbf{Отсутствие поддержки полиморфизма для mutation.}

В то время как для object можно задать другой object в качестве интерфейса (либо использовать union), для полей в mutation наследование не предусмотрено.
Например, нужно передать информацию о владельце счёта.
Если владельцем является физическое лицо, то нужны его фамилия, имя и отчество, а для юридического лица – наименование предприятия.
В случае с REST клиент может передать дополнительное поле, содержащее тип владельца счёта, и сервер сможет осуществить десериализацию в нужный тип.
А при использовании GraphQL придётся создать отдельный запрос для каждого типа.

\textbf{Отсутствие namespaces.}

Один GraphQL сервис имеет единственную схему.
В случае большого проекта схема может достигать значительных объёмов, и ориентирование в ней потребует наличие дополнительной документации, а также увеличивается вероятность коллизии имён.
REST в свою очередь не использует такое понятие как тип передаваемого объекта, и управление ими осуществляется средствами клиента и сервера в отдельности.

\textbf{Ограничение использования подхода Backend Driven UI.}

При использовании этого подхода управление пользовательским интерфейсом передаётся на серверную сторону: приложение представляет из себя набор виджетов.
А список и порядок виджетов, отображаемых на каждом экране, содержимое каждого виджета, а также способ перехода между экранами, приложение получает от сервера.
При использовании GraphQL разработчик должен будет решить, каким образом передавать изменяющийся запрос с сервера на устройство, либо в ответ на каждое изменение редактировать схему, создавая или изменяя имеющиеся query.

Как видно, обе технологии имеют свои преимущества и недостатки, но решение об использовании того или иного подхода должно приниматься с учётом специфики конкретного проекта.


\section{Проблемы миграции на GraphQL}\label{sec:migration-to-graphql}

В случае, если разработчики решат начать использовать GraphQL в уже существующем продукте, они могут столкнуться с рядом проблем.
Чтобы наглядно продемонстрировать возможные проблемы, рассмотрим пример.

Допустим, что некая компания имеет мобильное приложение для платформ Android и iOS, а также веб-версии приложений для компьютеров и мобильных устройств.
Часть пользователей не имеет возможности обновлять приложение из-за того, что их версия операционной системы больше не поддерживается приложением, однако компания не желает терять прибыль от этих пользователей.

В компании периодически производится редизайн приложения, в связи с чем на большом количестве экранов меняется формат представления данных, в связи с чем должны быть изменены и форматы запросов к серверу и ответов от него.
Из-за большого количества имеющихся платформ сильно возрастает нагрузка на разработчиков серверной части, так как необходимо разрабатывать сервисы с учётом различий в представлении результата на каждой платформе.

Использование GraphQL позволило бы снизить нагрузку на разработчиков серверной части, так как в этом случае им достаточно создать ряд универсальных источников и предоставить схему, для которой разработчики клиентских приложений будут писать запросы.

Однако внедрение новой технологии означает, что её использованию необходимо обучить каждого разработчика каждой из платформ, а затем в течение длительного времени поддерживать одновременно две версии API – GraphQL для новых версий приложения, и REST для старых.


\section{Предлагаемая технология}\label{sec:proposed-technology}

В качестве решения для перечисленных проблем автор предлагает создание дополнительного сервиса в виде адаптера между REST-клиентом и GraphQL-сервером.
Данный сервис должен хранить маппинг (соответствие между запросами двух типов), и при получении REST-запроса находить в своей базе соответствующий шаблон GraphQL-запроса, заполнять его данными из REST-запроса и отправлять к GraphQL-сервису для выполнения.

Помимо описанной основной функциональности также возможна реализация следующих функциональностей:

\begin{itemize}
	\item В случае, если для REST-запроса не было найдено соответствия, то запрос должен быть передан gateway-сервису – таким образом, описываемый сервис может стать единственной точкой доступа к системе.
	\item При необходимости может быть реализовано приведение ответа GraphQL-сервиса к другому виду с целью сохранения обратной совместимости.
\end{itemize}

\subsection{Достоинства предлагаемой технологии}\label{sec:proposed-technology-advantages}

Рассмотрим достоинства данного подхода в сравнении с использованием REST либо GraphQL:

\begin{itemize}
	\item Гибкость и мощь языка GraphQL – разработчики имеют возможность писать полноценные GraphQL-запросы и разрабатывать серверную часть в соответствии со всеми принципами GraphQL.
	\item Обратная совместимость на клиенте – старая версия приложения может продолжать функционировать после полного перехода на использование GraphQL на сервере¬¬.
	\item Разработчикам клиентских приложений не нужно обучаться новой технологии и внедрять её – взаимодействие с сервером по-прежнему осуществляется через привычный REST.
	\item Обязанности по написанию, отладке и редактированию запросов могут брать на себя также аналитики и сотрудники отдела сопровождения, не требуя участия разработчиков.
	\item Возможность постепенной миграции – запросы, которые не были реализованы в GraphQL, передаются старым сервисам, и затем неявно подменяются новой реализацией.
	\item Такой сервис может обращаться ко множеству различных GraphQL-сервисов, позволяя разграничить зоны ответственности и решить проблему именования.
	\item Есть возможность использовать существующие механизмы кеширования на клиенте и промежуточных узлах, непригодные для использования с GraphQL.
	\item Подобная система может быть реализована для любого протокола общения с клиентом – например, вместо REST может использоваться протокол SOAP.
	\item Для добавления и изменения маппинга необязательна перезагрузка сервиса, что позволяет вносить и проверять изменения гораздо быстрее, чем это происходит при изменении кода.
	Актуализация маппинга может происходить периодически, при обнаружении изменений или по иному событию.
	\item Возможность редактирования запроса на сервере в реальном времени, что невозможно при использовании механизма Persistent Queries, при котором клиент использует хэш-код одного из заранее заданных неизменяемых запросов.
	\item Настройки могут браться из любого типа источника – git или другой системы контроля версий, базы данных, config-серверов, локальных yaml-файлов и т.п.
	\item Хранение маппингов в системе контроля версий позволит использовать уже имеющуюся ролевую модель, в том числе налаженные процессы для ревью изменений, а также защитить маппинги от несанкционированного изменения и утраты, использовать версионирование.
	\item Форматом ответа можно легко манипулировать с помощью технологий для форматирования JSON – например, библиотеки JOLT [6].
	\item В случае миграции с данного решения на использование GraphQL без посредников разработчики будут иметь в своём распоряжении готовые и протестированные GraphQL-запросы.
	А для поддержки старых версий приложения после миграции не придётся поддерживать старый REST-кластер, а только данный сервис.
	\item Уменьшается объём кода, отвечающего за отображение, в сервисах.
	Появляется новый уровень абстракции, позволяющий разработчикам писать более чистый код.
	\item Данный сервис в качестве отдельного слоя может быть протестирован независимо от остальной системы при помощи автотестов: для этого могут использоваться «заглушки», вызываемые вместо реальных сервисов на тестовом стенде.
\end{itemize}

\subsection{Недостатки предлагаемой технологии}\label{sec:proposed-technology-disadvantages}

\begin{itemize}
	\item Дополнительный элемент в цепочке вызовов замедляет выполнение запросов.
	\item Сервис и источники маппингов являются новыми потенциальной точкой отказа.
	\item В случае недоступности источника маппингов сервис не сможет быть перезапущен – необходимо предусмотреть дополнительный источник.
	\item При росте количества маппингов может значительно возрасти сложность поддержки системы.
	\item Нужен новый механизм тестирования изменений.
	Те действия, которые ранее были покрыты юнит-тестами в сервисах, теперь могут быть протестированы только с помощью автотестов и сервисов-заглушек.
\end{itemize}

Как видно, количество ожидаемых преимуществ значительно превышает количество ожидаемых недостатков, в связи с чем разработку подобной системы считаем целесообразной.


%\FloatBarrier % заставить рисунки и другие подвижные (float) элементы остановиться

\section{Выводы} \label{ch1:conclusion}

Текст выводов по главе \thechapter.

Кроме названия параграфа <<выводы>> можно использовать (единообразно по всем главам) следующие подходы к именованию последних разделов с результатами по главам:
\begin{itemize}
	\item <<выводы по главе N>>, где N --- номер соответствующей главы;
	\item <<резюме>>;
	\item <<резюме по главе N>>, где N --- номер соответствующей главы.
\end{itemize}

Параграф с изложением выводов по главе \textit{является обязательным}.

%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы