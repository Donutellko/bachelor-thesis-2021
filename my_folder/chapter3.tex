%! suppress = Unicode
\chapter{ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ СЕРВИСА}\label{ch:ch3}

\textbf{Хорошим стилем является наличие введения к главе, которое \textit{начинается непосредственно после названия главы, без оформления в виде отдельного параграфа}.}

\section{Требования к прототипу}\label{ch3:sec1}

К прототипу предъявляются не все из требований, перечисленных в требованиях к реализации.
В частности, прототип:

\begin{itemize}
	\item загружает маппинги из настроек, расположенных локально в файле application.yml;
	\item при перенаправлении запроса к другому эндпоинту обрабатывает только успешные ответы от этого эндпоинта;
	\item не осуществляет трансформирование ответа в формате JSON, полученного от GraphQL-сервиса;
	\item допускает любое поведение при наличии нескольких подходящих маппингов.
\end{itemize}

\section{Реализация прототипа}\label{ch3:sec2}

Исходный код прототипа содержит ряд пакетов, логически разделяющих классы.
Каждый пакет представляет из себя уровень абстракции над действиями, выполняемыми сервисом при обработке запросов.
Исходные коды классов приведены в приложении 8.

\subsection{Пакет controller}

Данный пакет включает в себя классы, ответственные за принятие запроса к сервису и отправку ответа.
В прототипе этот пакет имеет единственный класс ApiController, имеющий единственный метод endpoint, который принимает объект запроса и передаёт его в RequestProcessService, который будет рассмотрен далее.

\subsection{Пакет service}

Данный пакет включает в себя классы, ответственные за так называемую бизнес-логику и содержит следующие классы:

\begin{itemize}
	\item MappingMatcherService – получает метод и uri полученного запроса и находит для него маппинг.
	\item TemplateFillerService – получает значения переменных из URI, query parameters и body и использует их для заполнения шаблона GraphQL-запроса.
	\item ForwarderService – ответственнен за перенаправление запроса в Gateway API с сохранением URI, headers, query parameters и body.
	\item RequestProcessService получает объект запроса и вызывает MappingMatcherService для поиска маппинга.
	Если маппинг не был найден, то он передаёт объект запроса в ForwarderService и возвращает ответ, полученный от Gateway API. Если маппинг был найден, то он использует TemplateFillerService для создания GraphQL-запроса, выполняет его с помощью GraphClient, который будет рассмотрен далее, и возвращает полученный ответ пользователю.
\end{itemize}


\subsection{Пакет util}

Данный пакет включает в себя единственный класс VariableUtils, который содержит утилитарные методы для:

\begin{itemize}
	\item получения маски маппинга, которая будет использована для сравнения с пришедшим запросом;
	\item получения списка переменных, которые ожидается найти в пришедшем запросе;
	\item получения значения переменных из пришедшего запроса.
\end{itemize}

Для получения значений из тела запроса, представляющего из себя JSON, использована библиотека JsonPath.

\subsection{Пакет property}

Данный пакет включает в себя класс MappingProperties, содержащий маппинги, загруженные из файла application.yml.

\subsection{Пакет client}

Данный пакет включает в себя единственный класс GraphClient, который содержит единственный метод send, который вызывает GraphQL-сервис по переданному адресу с переданным тестом запроса.
Запросы отправляются с помощью технологии WebClient, выполняющей запросы с использованием реактивного (неблокирующего) подхода.

\subsection{Модуль test}

Данный модуль содержит в себе юнит-тесты для проверки работы ряда сервисов, а также несколько интеграционных сервисов, проверяющих работоспособность системы вцелом.
Интеграционные тесты утилизируют тестовые данные, подготовленные в разделе 2.3, причём вместо вызова внешних систем реализуются заглушки с помощью технологии WireMock, позволяющей указать ожидаемый запрос и соответствующий ему ответ.


\section{Выводы} \label{sec:ch3-conclusion}

Параграф с изложением выводов по главе \textit{является обязательным}.