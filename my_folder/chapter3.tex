%! suppress = Unicode
\chapter{ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ СЕРВИСА}\label{ch:ch3}

\textbf{Хорошим стилем является наличие введения к главе, которое \textit{начинается непосредственно после названия главы, без оформления в виде отдельного параграфа}.}

\section{Выбор технологий}\label{sec:choose-technology}

Для системы, реализуемой в рамках выпускной квалификационной работы, в дальнейшем будет использоваться название R2G (Rest to GraphQL).

Для создания системы будет использован Spring Framework, являющийся одним из самых распространённых и мощных фреймворков для создания веб-сервисов.
Spring Framework включает в себя множество различных модулей, которые позволяют значительно ускорить разработку и уменьшить количество необходимого кода за счёт использования многочисленных дополнительных модулей.
В частности, будут использованы следующие модули:

\begin{itemize}
	\item Spring Boot позволяет подключать так называемые starters, которые включают в себя другие модули и упрощают их конфигурирование.
	\item Spring Web используется для создания эндпоинтов для обработки входящих REST-запросов.
	\item Spring Cloud Config для управления настройками сервиса, в частности для возможности получения настроек и маппингов из git-репозитория.
\end{itemize}

Spring Framework изначально разрабатывался для использования с языком Java, однако на данный момент поддерживает значительное число языков JVM, и в рамках данной работы будет использован язык Kotlin, имеющий среди преимуществ перед Java лаконичность и возможность использования корутин (легковесных потоков) для повышения производительности и упрощения использования реактивного подхода.

Для взаимодействия с GraphQL-сервисами существуют специальные библиотеки, как например Apollo Client, позволяющие упростить создание клиентских приложений за счёт генерации кода на основании схемы и GraphQL-запросов.
Однако подобный подход неприменим в данном случае, так как разрабатываемый сервис должен уметь работать с GraphQL-сервисами в общем случае.
Поэтому для обращения к GraphQL-сервисам будет использован обычный HTTP-клиент.

Для преобразования результатов используем технологию JOLT, так как она является достаточно мощной технологией, позволяющей осуществлять разнообразные манипуляции с JSON, позволяет писать юнит-тесты для проверки написанных преобразований, а также одной из немногих подобных технологий имеет реализацию в виде библиотеки для Java.


\section{Требования к реализации}\label{ch3:sec1}

К прототипу предъявляются не все из требований, перечисленных в требованиях к реализации.
В частности, прототип:

\begin{itemize}
	\item загружает маппинги из настроек, расположенных локально в файле application.yml;
	\item при перенаправлении запроса к другому эндпоинту обрабатывает только успешные ответы от этого эндпоинта;
	\item не осуществляет трансформирование ответа в формате JSON, полученного от GraphQL-сервиса;
	\item допускает любое поведение при наличии нескольких подходящих маппингов.
\end{itemize}

\section{Обзор исходных кодов реализации}\label{ch3:sec2}

Исходный код прототипа содержит ряд пакетов, логически разделяющих классы.
Каждый пакет представляет из себя уровень абстракции над действиями, выполняемыми сервисом при обработке запросов.
Исходные коды классов приведены в приложении 8.

\subsection{Пакет controller}

Данный пакет включает в себя классы, ответственные за принятие запроса к сервису и отправку ответа.
В прототипе этот пакет имеет единственный класс ApiController, имеющий единственный метод endpoint, который принимает объект запроса и передаёт его в RequestProcessService, который будет рассмотрен далее.

\subsection{Пакет service}

Данный пакет включает в себя классы, ответственные за так называемую бизнес-логику и содержит следующие классы:

\begin{itemize}
	\item MappingMatcherService – получает метод и uri полученного запроса и находит для него маппинг.
	\item TemplateFillerService – получает значения переменных из URI, query parameters и body и использует их для заполнения шаблона GraphQL-запроса.
	\item ForwarderService – ответственнен за перенаправление запроса в Gateway API с сохранением URI, headers, query parameters и body.
	\item RequestProcessService получает объект запроса и вызывает MappingMatcherService для поиска маппинга.
	Если маппинг не был найден, то он передаёт объект запроса в ForwarderService и возвращает ответ, полученный от Gateway API. Если маппинг был найден, то он использует TemplateFillerService для создания GraphQL-запроса, выполняет его с помощью GraphClient, который будет рассмотрен далее, и возвращает полученный ответ пользователю.
\end{itemize}


\subsection{Пакет util}

Данный пакет включает в себя единственный класс VariableUtils, который содержит утилитарные методы для:

\begin{itemize}
	\item получения маски маппинга, которая будет использована для сравнения с пришедшим запросом;
	\item получения списка переменных, которые ожидается найти в пришедшем запросе;
	\item получения значения переменных из пришедшего запроса.
\end{itemize}

Для получения значений из тела запроса, представляющего из себя JSON, использована библиотека JsonPath.

\subsection{Пакет property}

Данный пакет включает в себя класс MappingProperties, содержащий маппинги, загруженные из файла application.yml.

\subsection{Пакет client}

Данный пакет включает в себя единственный класс GraphClient, который содержит единственный метод send, который вызывает GraphQL-сервис по переданному адресу с переданным тестом запроса.
Запросы отправляются с помощью технологии WebClient, выполняющей запросы с использованием реактивного (неблокирующего) подхода.

\subsection{Модуль test}

Данный модуль содержит в себе юнит-тесты для проверки работы ряда сервисов, а также несколько интеграционных сервисов, проверяющих работоспособность системы вцелом.
Интеграционные тесты утилизируют тестовые данные, подготовленные в разделе 2.3, причём вместо вызова внешних систем реализуются заглушки с помощью технологии WireMock, позволяющей указать ожидаемый запрос и соответствующий ему ответ.


\section{Выводы} \label{sec:ch3-conclusion}

Параграф с изложением выводов по главе \textit{является обязательным}.